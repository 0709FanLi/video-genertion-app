即梦AI-视频生成3.0 Pro-接口文档
最近更新时间：2025.10.23 16:00:46
首次发布时间：2025.08.05 15:22:28

我的收藏
有用
无用
接口简介​
即梦视频3.0Pro —— 即梦同源的文生视频与图生视频能力，在视频生成效果上实现飞跃，各维度均表现优异。该版本具备多镜头叙事能力，能更精准遵循指令，动态表现流畅自然，支持生成1080P高清且具专业级质感的视频，还可实现更丰富多元的风格化表达。​
即梦视频3.0Pro支持功能含：​
文生视频：输入文本提示词，生成视频；​
图生视频-首帧：输入首帧图片和对应的文本提示词，生成视频。​
​
接入说明​
请求说明​
​
名称​
内容​
接口地址​
https://visual.volcengineapi.com​
请求方式​
POST​
Content-Type​
application/json​
​
提交任务​
提交任务请求参数​
Query参数​
拼接到url后的参数，示例：https://visual.volcengineapi.com?Action=CVSync2AsyncSubmitTask&Version=2022-08-31​
​
参数​
类型​
可选/必选​
说明​
Action​
string​
必选​
接口名，取值：CVSync2AsyncSubmitTask​
Version​
string​
必选​
版本号，取值：2022-08-31​
​
Header参数​
注意​
本服务固定值：Region为cn-north-1，Service为cv​
主要用于鉴权，详见 公共参数 - 签名参数 - 在Header中的场景部分​
Body参数​
注意​
业务请求参数，放到request.body中，MIME-Type为application/json​
​
参数​
类型​
可选/必选​
说明​
req_key​
string​
必选​
服务标识​
取固定值: jimeng_ti2v_v30_pro​
prompt​
string​
可选​
文生视频场景必选​
用于生成视频的提示词 ，中英文均可输入。建议在400字以内，不超过800字，prompt过长有概率出现效果异常或不生效​
binary_data_base64​
array of string​
可选​
图生视频场景图片和prompt二选一必选​
传图时binary_data_base64和image_urls参数二选一​
图片文件base64编码，仅支持输入1张图片（图生视频仅支持传入首帧），仅支持JPEG、PNG格式；​
注意：​
图片文件大小：最大 4.7MB​
图片分辨率：最大 4096 * 4096，最短边不低于320；​
图片长边与短边比例在3以内；​
image_urls​
图片文件URL，仅支持输入1张图片（图生视频仅支持传入首帧）​
注意：​
图片长边与短边比例在3以内；​
seed​
int​
可选​
随机种子，作为确定扩散初始状态的基础，默认-1（随机）。若随机种子为相同正整数且其他参数均一致，则生成视频极大概率效果一致​
默认值：-1​
frames​
int​
可选​
生成的总帧数（帧数 = 24 * n + 1，其中n为秒数，支持5s、10s）​
可选取值：[121, 241]​
默认值：121​
aspect_ratio​
string​
可选​
生成视频的长宽比，只在文生视频场景下生效，图生视频场景会根据输入图的长宽比从可选取值中选择最接近的比例生成；​
可选取值：["16:9", "4:3", "1:1", "3:4", "9:16", "21:9"]​
默认值："16:9"​
​
生成视频长宽与比例的对应关系如下：​
2176 * 928（21:9）​
1920 * 1088（16:9）​
1664 * 1248（4:3）​
1440 * 1440 （1:1）​
1248 * 1664（3:4）​
1088 * 1920（9:16）​
​
图片裁剪规则​
​
图生视频场景，当传入的图片与可选的取值["16:9", "4:3", "1:1", "3:4", "9:16", "21:9"]的宽高比不一致时，系统会对图片进行裁剪，裁剪时会居中裁剪，详细规则如下：​
说明​
如果希望呈现较好的视频效果，建议上传图片宽高比与可选的宽高比取值["16:9", "4:3", "1:1", "3:4", "9:16", "21:9"]尽可能接近。​
输入参数：​
输入图片宽度记为W，高度记为H。​
假设输入图片最接近的目标比例记为A:B（例如：16:9），则裁剪后的宽度与高度之比应为A:B。​
比较宽高比：​
计算输入图片的宽高比Ratio_原始=W/H。​
计算目标比例的比值Ratio_目标=A/B。​
根据比较结果，决策裁剪基准：​
如果Ratio_原始 < Ratio_目标(即传入图片“太高”或“竖高”)，则以宽度为基准裁剪。​
如果Ratio_原始 > Ratio_目标(即传入图片“太宽”或“横宽”)，则以高度为基准裁剪。​
如果相等，则无需裁剪，直接使用全图。​
裁剪尺寸计算：​
以宽度为基准（适用于传入图片“太高”或“竖高”场景）：​
裁剪宽度Crop_W=W（使用输入图片原始宽度）。​
裁剪高度Crop_H=W*(B/A)（根据目标比例等比例计算高度）。​
裁剪区域的起始坐标（居中定位）：​
X坐标（水平）：总是0（因为宽度全用，从左侧开始）。​
Y坐标（垂直）：(H-Crop_H)/2（确保垂直居中，从顶部开始）。​
以高度为基准（适用于传入图片“太宽”或“横宽”）：​
裁剪高度Crop_H=H（使用整个原始高度）。​
裁剪宽度Crop_W=H*(A/B)（根据目标比例等比例计算宽度）。​
裁剪区域的起始坐标（居中定位）：​
X坐标（水平）：(W-Crop_W)/2（确保水平居中，从左侧开始）。​
Y坐标（垂直）：总是0（因为高度全用，从顶部开始）。​
裁剪结果：​
最终裁剪出的图片尺寸为Crop_W*Crop_H，比例严格等于A:B，且完全位于原始图片内部，无黑边。​
裁剪区域总是以原始图片中心为基准，因此内容居中。​
裁剪示例：​
​
输入图片​
生成的视频结果​
输入图片宽高：3380*1072​
与输入图片接近的宽高比：21:9​
​​​
​
​
​​
输入图片宽高：936*1664​
与输入图片接近的宽高比：9:16​
​​​
​
​​
​
​
​
​
​
​
提交任务返回参数​
通用返回参数​
请参考通用返回字段及错误码​
业务返回参数​
重点关注data中以下字段，其他字段为公共返回(可忽略或不做解析)​
​
字段​
类型​
说明​
task_id​
string​
任务ID，用于查询结果​
​
提交任务请求&返回完整示例​
请求示例：​
​
{​
    "req_key": "jimeng_ti2v_v30_pro",​
    // "binary_data_base64": [],​
    "image_urls": [​
        "https://xxx"​
    ],​
    "prompt": "千军万马",​
    "seed": -1,​
    "frames": 121,​
    "aspect_ratio": "16:9"​
}​
​
返回示例：​
​
{​
    "code": 10000,​
    "data": {​
        "task_id": "7392616336519610409"​
    },​
    "message": "Success",​
    "request_id": "20240720103939AF0029465CF6A74E51EC",​
    "status": 10000,​
    "time_elapsed": "104.852309ms"​
}​
​
查询任务​
查询任务请求参数​
Query参数​
拼接到url后的参数，示例：https://visual.volcengineapi.com?Action=CVSync2AsyncGetResult&Version=2022-08-31​
​
参数​
类型​
可选/必选​
说明​
Action​
string​
必选​
接口名，固定值：CVSync2AsyncGetResult​
Version​
string​
必选​
版本号，固定值：2022-08-31​
​
Header参数​
注意​
本服务固定值：Region为cn-north-1，Service为cv​
主要用于鉴权，详见 公共参数 - 签名参数 - 在Header中的场景部分​
Body参数​
注意​
业务请求参数，放到request.body中，MIME-Type为application/json​
​
参数​
类型​
可选/必选​
说明​
​
req_key​
String​
必选​
服务标识​
取固定值: jimeng_ti2v_v30_pro​
​
task_id​
String​
必选​
任务ID，此字段的取值为提交任务接口的返回​
​
req_json​
JSON String​
可选​
json序列化后的字符串,目前支持隐性水印配置，可在返回结果中添加​
示例："{\"aigc_meta\": {\"content_producer\": \"xxxxxx\", \"producer_id\": \"xxxxxx\", \"content_propagator\": \"xxxxxx\", \"propagate_id\": \"xxxxxx\"}}"​
​
ReqJson(序列化后的结果再赋值给req_json)​
配置信息​
​
参数​
类型​
可选/必选​
说明​
​
aigc_meta​
AIGCMeta​
可选​
隐式标识​
隐式标识验证方式：​
https://www.gcmark.com/web/index.html#/mark/check/video​
验证，先注册帐号 上传打标后的视频 点击开始检测 输出检测结果如下图即代表成功​
​​​
​
AIGCMeta​
隐式标识，依据《人工智能生成合成内容标识办法》&《网络安全技术人工智能生成合成内容标识方法》​
​
名称​
类型​
可选/必选​
描述​
content_producer​
string​
可选​
内容生成服务ID（长度 <= 256字符）​
producer_id​
string​
必选​
内容生成服务商给此图片数据的唯一ID（长度 <= 256字符）​
content_propagator​
string​
必选​
内容传播服务商ID（长度 <= 256字符）​
propagate_id​
string​
可选​
传播服务商给此图片数据的唯一ID（长度 <= 256字符）​
​
查询任务返回参数​
通用返回参数​
请参考通用返回字段及错误码​
业务返回参数​
说明​
重点关注data中以下字段，其他字段为公共返回(可忽略或不做解析)​
​
参数名​
类型​
​
video_url​
string​
生成的视频URL（有效期为 1 小时）​
aigc_meta_tagged​
bool​
隐式标识是否打标成功​
status​
string​
任务执行状态​
in_queue：任务已提交​
generating：任务已被消费，处理中​
done：处理完成，成功或者失败，可根据外层code&message进行判断​
not_found：任务未找到，可能原因是无此任务或任务已过期(12小时)​
expired：任务已过期，请尝试重新提交任务请求​
​
查询任务请求&返回完整示例​
请求示例：​
​
{​
    "req_key": "jimeng_ti2v_v30_pro",​
    "task_id": "7491596536074305586",​
    "req_json": "{\"aigc_meta\": {\"content_producer\": \"001191440300192203821610000\", \"producer_id\": \"producer_id_test123\", \"content_propagator\": \"001191440300192203821610000\", \"propagate_id\": \"propagate_id_test123\"}}"​
}​
​
返回示例：​
​
{​
    "code": 10000,​
    "data": {​
        "aigc_meta_tagged": true,​
        "status": "done",​
        "video_url": "https://xxxx"​
    },​
    "message": "Success",​
    "request_id": "20250805144938F6E5264E9D24EB0C4E0A",​
    "status": 10000,​
    "time_elapsed": "57.354545ms"​
}​
​
错误码​
通用错误码​
请参考通用返回字段及错误码​
业务错误码​
​
HttpCode​
错误码​
错误消息​
描述​
是否需要重试​
200​
10000​
无​
请求成功​
不需要​
400​
50411​
Pre Img Risk Not Pass​
输入图片前审核未通过​
不需要​
400​
50511​
Post Img Risk Not Pass​
输出图片后审核未通过​
可重试​
400​
50412​
Text Risk Not Pass​
输入文本前审核未通过​
不需要​
400​
50512​
Post Text Risk Not Pass​
输出文本后审核未通过​
不需要​
400​
50413​
Post Text Risk Not Pass​
输入文本含敏感词、版权词等审核不通过​
不需要​
429​
50429​
Request Has Reached API Limit, Please Try Later​
QPS超限​
可重试​
429​
50430​
Request Has Reached API Concurrent Limit, Please Try Later​
并发超限​
可重试​
500​
50500​
Internal Error​
内部错误​
可重试​
500​
50501​
Internal RPC Error​
内部算法错误​
可重试​
​
php请求示例

<?php
/**
 * Copyright (year) Beijing Volcano Engine Technology Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
require('../vendor/autoload.php');
// 需要自行安装 composer（https://getcomposer.org/doc/00-intro.md），并安装GuzzleHttp依赖， composer require guzzlehttp/guzzle:^7.0
use GuzzleHttp\Client;
use GuzzleHttp\Exception\GuzzleException;

// 基础信息，基本不用变更
$Host = "visual.volcengineapi.com";
$ContentType = "application/json";
$Service = "cv";
$Region = "cn-north-1";

/**
 * @throws GuzzleException
 */
// 第一步：创建一个  API 请求函数。签名计算的过程包含在该函数中。
function request($method, $query, $header, $ak, $sk, $action, $version, $body)
{
    // 第二步：创建身份证明。其中的 Service 和 Region 字段是固定的。ak 和 sk 分别代表
    // AccessKeyID 和 SecretAccessKey。同时需要初始化签名结构体。一些签名计算时需要的属性也在这里处理。
    // 初始化身份证明结构体
    global $Service, $Region, $Host, $ContentType;
    $credential = [
        'accessKeyId' => $ak,
        'secretKeyId' => $sk,
        'service' => $Service,
        'region' => $Region,
    ];
    // 初始化签名结构体
    $query = array_merge($query, [
        'Action' => $action,
        'Version' => $version
    ]);
    ksort($query);
    $requestParam = [
        // body是http请求需要的原生body
        'body' => $body,
        'host' => $Host,
        'path' => '/',
        'method' => $method,
        'contentType' => $ContentType,
        'date' => gmdate('Ymd\THis\Z'),
        'query' => $query
    ];
    // 第三步：接下来开始计算签名。在计算签名前，先准备好用于接收签算结果的 signResult 变量，并设置一些参数。
    // 初始化签名结果的结构体
    $xDate = $requestParam['date'];
    $shortXDate = substr($xDate, 0, 8);
    $xContentSha256 = hash('sha256', $requestParam['body']);
    $signResult = [
        'Host' => $requestParam['host'],
        'X-Content-Sha256' => $xContentSha256,
        'X-Date' => $xDate,
        'Content-Type' => $requestParam['contentType']
    ];
    // 第四步：计算 Signature 签名。
    $signedHeaderStr = join(';', ['content-type', 'host', 'x-content-sha256', 'x-date']);
    $canonicalRequestStr = join("\n", [
        $requestParam['method'],
        $requestParam['path'],
        http_build_query($requestParam['query']),
        join("\n", ['content-type:'. $requestParam['contentType'], 'host:'. $requestParam['host'], 'x-content-sha256:'. $xContentSha256, 'x-date:'. $xDate]),
        '',
        $signedHeaderStr,
        $xContentSha256
    ]);
    $hashedCanonicalRequest = hash("sha256", $canonicalRequestStr);
    $credentialScope = join('/', [$shortXDate, $credential['region'], $credential['service'], 'request']);
    $stringToSign = join("\n", ['HMAC-SHA256', $xDate, $credentialScope, $hashedCanonicalRequest]);
    $kDate = hash_hmac("sha256", $shortXDate, $credential['secretKeyId'], true);
    $kRegion = hash_hmac("sha256", $credential['region'], $kDate, true);
    $kService = hash_hmac("sha256", $credential['service'], $kRegion, true);
    $kSigning = hash_hmac("sha256", 'request', $kService, true);
    $signature = hash_hmac("sha256", $stringToSign, $kSigning);
    $signResult['Authorization'] = sprintf("HMAC-SHA256 Credential=%s, SignedHeaders=%s, Signature=%s", $credential['accessKeyId']. '/'. $credentialScope, $signedHeaderStr, $signature);
    $header = array_merge($header, $signResult);
    // 第五步：将 Signature 签名写入 HTTP Header 中，并发送 HTTP 请求。
    $client = new Client([
        'base_uri' => 'https://'. $requestParam['host'],
        'timeout' => 120.0,
    ]);
    $response = $client->request($method, 'https://'. $requestParam['host']. $requestParam['path'], [
        'headers' => $header,
        'query' => $requestParam['query'],
        'body' => $requestParam['body']
    ]);
    $responseContent = $response->getBody()->getContents();
    // 转换 \u0026 为 &
    $responseContent = str_replace('\u0026', '&', $responseContent);
    return $responseContent;
}
$now = time();
// 火山官网密钥信息, 注意sk结尾有==
$AccessKeyID = 'AK*****';
$SecretAccessKey = '*****==';

// 参考接口文档Query参数
$action = "CVProcess";
$version = "2022-08-31";

// 参考接口文档Body参数
$requestBody = [
    "req_key" => "******",
    //......
];
$body = json_encode($requestBody);

try {
    $response = request("POST", [], [], $AccessKeyID, $SecretAccessKey, $action, $version, $body);
    print_r($response);
} catch (GuzzleException $e) {
    print_r($e->getResponse()->getBody()->getContents() . "\n");
}