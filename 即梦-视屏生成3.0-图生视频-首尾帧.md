即梦AI-视频生成3.0 1080P-图生视频-首尾帧-接口文档
最近更新时间：2025.10.23 16:02:22
首次发布时间：2025.08.26 14:41:33
我的收藏
有用
无用
接口简介​
即梦视频3.0 —— 即梦同源的文生视频能力，专业级视频生成引擎，释放无限创意。 准确遵循复杂指令，视觉表达流畅一致，支持1080P高清渲染，更可驾驭多元艺术风格，在视频生成质量出色的基础上，是生成效果与速度兼备的高性价比之选。​
本文档重点阐述1080P-图生视频-首尾帧的接口说明。​
接入说明​
请求说明​
​
名称​
内容​
接口地址​
https://visual.volcengineapi.com​
请求方式​
POST​
Content-Type​
application/json​
​
提交任务​
提交任务请求参数​
Query参数​
拼接到url后的参数，示例：https://visual.volcengineapi.com?Action=CVSync2AsyncSubmitTask&Version=2022-08-31​
​
参数​
类型​
可选/必选​
说明​
Action​
string​
必选​
接口名，取值：CVSync2AsyncSubmitTask​
Version​
string​
必选​
版本号，取值：2022-08-31​
​
Header参数​
注意​
本服务固定值：Region为cn-north-1，Service为cv​
主要用于鉴权，详见 公共参数 - 签名参数 - 在Header中的场景部分​
Body参数​
注意​
业务请求参数，放到request.body中，MIME-Type为application/json​
​
参数​
类型​
可选/必选​
说明​
req_key​
string​
必选​
服务标识​
取固定值: jimeng_i2v_first_tail_v30_1080​
binary_data_base64​
array of string​
必选（二选一）​
图片文件base64编码，请输入2张图片，仅支持JPEG、PNG格式；​
注意：​
图片文件大小：最大 4.7MB；​
图片分辨率：最大 4096 * 4096，最短边不低于320；​
图片长边与短边比例在3以内；​
尾帧图片需与首帧图片比例相同。​
image_urls​
图片文件URL，请输入2张图片​
注意：​
图片长边与短边比例在3以内；​
尾帧图片需与首帧图片比例相同。​
prompt​
string​
必选​
用于生成视频的提示词 ，中英文均可输入。建议在400字以内，不超过800字，prompt过长有概率出现效果异常或不生效​
seed​
int​
可选​
随机种子，作为确定扩散初始状态的基础，默认-1（随机）。若随机种子为相同正整数且其他参数均一致，则生成视频极大概率效果一致​
默认值：-1​
frames​
int​
可选​
生成的总帧数（帧数 = 24 * n + 1，其中n为秒数，支持5s、10s）​
可选取值：[121, 241]​
默认值：121​
​
提交任务返回参数​
通用返回参数​
请参考通用返回字段及错误码​
业务返回参数​
重点关注data中以下字段，其他字段为公共返回(可忽略或不做解析)​
​
字段​
类型​
说明​
task_id​
string​
任务ID，用于查询结果​
​
提交任务请求&返回完整示例​
请求示例：​
​
{​
    "req_key": "jimeng_i2v_first_tail_v30_1080",​
    // "binary_data_base64": [],​
    "image_urls": [​
        "https://xxx",​
        "https://xxx"​
    ],​
    "prompt": "千军万马",​
    "seed": -1,​
    "frames": 121​
}​
​
返回示例：​
​
{​
    "code": 10000,​
    "data": {​
        "task_id": "7392616336519610409"​
    },​
    "message": "Success",​
    "request_id": "20240720103939AF0029465CF6A74E51EC",​
    "status": 10000,​
    "time_elapsed": "104.852309ms"​
}​
​
查询任务​
查询任务请求参数​
Query参数​
拼接到url后的参数，示例：https://visual.volcengineapi.com?Action=CVSync2AsyncGetResult&Version=2022-08-31​
​
参数​
类型​
可选/必选​
说明​
Action​
string​
必选​
接口名，固定值：CVSync2AsyncGetResult​
Version​
string​
必选​
版本号，固定值：2022-08-31​
​
Header参数​
注意​
本服务固定值：Region为cn-north-1，Service为cv​
主要用于鉴权，详见 公共参数 - 签名参数 - 在Header中的场景部分​
Body参数​
注意​
业务请求参数，放到request.body中，MIME-Type为application/json​
​
参数​
类型​
可选/必选​
说明​
​
req_key​
string​
必选​
服务标识​
取固定值: jimeng_i2v_first_tail_v30_1080​
​
task_id​
string​
必选​
任务ID，此字段的取值为提交任务接口的返回​
​
req_json​
json string​
可选​
json序列化后的字符串,目前支持隐性水印配置，可在返回结果中添加​
示例："{\"aigc_meta\": {\"content_producer\": \"xxxxxx\", \"producer_id\": \"xxxxxx\", \"content_propagator\": \"xxxxxx\", \"propagate_id\": \"xxxxxx\"}}"​
​
ReqJson(序列化后的结果再赋值给req_json)​
配置信息​
​
参数​
类型​
可选/必选​
说明​
​
aigc_meta​
AIGCMeta​
可选​
隐式标识​
隐式标识验证方式：​
https://www.gcmark.com/web/index.html#/mark/check/video​
验证，先注册帐号 上传打标后的视频 点击开始检测 输出检测结果如下图即代表成功​
​​​
​
AIGCMeta​
隐式标识，依据《人工智能生成合成内容标识办法》&《网络安全技术人工智能生成合成内容标识方法》​
​
名称​
类型​
可选/必选​
描述​
content_producer​
string​
可选​
内容生成服务ID（长度 <= 256字符）​
producer_id​
string​
必选​
内容生成服务商给此图片数据的唯一ID（长度 <= 256字符）​
content_propagator​
string​
必选​
内容传播服务商ID（长度 <= 256字符）​
propagate_id​
string​
可选​
传播服务商给此图片数据的唯一ID（长度 <= 256字符）​
​
查询任务返回参数​
通用返回参数​
请参考通用返回字段及错误码​
业务返回参数​
说明​
重点关注data中以下字段，其他字段为公共返回(可忽略或不做解析)​
​
参数名​
类型​
​
video_url​
string​
生成的视频URL（有效期为 1 小时）​
aigc_meta_tagged​
bool​
隐式标识是否打标成功​
status​
string​
任务执行状态​
in_queue：任务已提交​
generating：任务已被消费，处理中​
done：处理完成，成功或者失败，可根据外层code&message进行判断​
not_found：任务未找到，可能原因是无此任务或任务已过期(12小时)​
expired：任务已过期，请尝试重新提交任务请求​
​
查询任务请求&返回完整示例​
请求示例：​
​
{​
    "req_key": "jimeng_i2v_first_tail_v30_1080",​
    "task_id": "7491596536074305586",​
    "req_json": "{\"aigc_meta\": {\"content_producer\": \"001191440300192203821610000\", \"producer_id\": \"producer_id_test123\", \"content_propagator\": \"001191440300192203821610000\", \"propagate_id\": \"propagate_id_test123\"}}"​
}​
​
返回示例：​
​
{​
    "code": 10000,​
    "data": {​
        "aigc_meta_tagged": true,​
        "status": "done",​
        "video_url": "https://xxxx"​
    },​
    "message": "Success",​
    "request_id": "20250805144938F6E5264E9D24EB0C4E0A",​
    "status": 10000,​
    "time_elapsed": "57.354545ms"​
}​
​
错误码​
通用错误码​
请参考通用返回字段及错误码​
业务错误码​
​
HttpCode​
错误码​
错误消息​
描述​
是否需要重试​
200​
10000​
无​
请求成功​
不需要​
400​
50411​
Pre Img Risk Not Pass​
输入图片前审核未通过​
不需要​
400​
50511​
Post Img Risk Not Pass​
输出图片后审核未通过​
可重试​
400​
50412​
Text Risk Not Pass​
输入文本前审核未通过​
不需要​
400​
50512​
Post Text Risk Not Pass​
输出文本后审核未通过​
不需要​
400​
50413​
Post Text Risk Not Pass​
输入文本含敏感词、版权词等审核不通过​
不需要​
429​
50429​
Request Has Reached API Limit, Please Try Later​
QPS超限​
可重试​
429​
50430​
Request Has Reached API Concurrent Limit, Please Try Later​
并发超限​
可重试​
500​
50500​
Internal Error​
内部错误​
不需要​
500​
50501​
Internal RPC Error​
内部算法错误​
不需要​
​
python请求示例

<?php
/**
 * Copyright (year) Beijing Volcano Engine Technology Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
require('../vendor/autoload.php');
// 需要自行安装 composer（https://getcomposer.org/doc/00-intro.md），并安装GuzzleHttp依赖， composer require guzzlehttp/guzzle:^7.0
use GuzzleHttp\Client;
use GuzzleHttp\Exception\GuzzleException;

// 基础信息，基本不用变更
$Host = "visual.volcengineapi.com";
$ContentType = "application/json";
$Service = "cv";
$Region = "cn-north-1";

/**
 * @throws GuzzleException
 */
// 第一步：创建一个  API 请求函数。签名计算的过程包含在该函数中。
function request($method, $query, $header, $ak, $sk, $action, $version, $body)
{
    // 第二步：创建身份证明。其中的 Service 和 Region 字段是固定的。ak 和 sk 分别代表
    // AccessKeyID 和 SecretAccessKey。同时需要初始化签名结构体。一些签名计算时需要的属性也在这里处理。
    // 初始化身份证明结构体
    global $Service, $Region, $Host, $ContentType;
    $credential = [
        'accessKeyId' => $ak,
        'secretKeyId' => $sk,
        'service' => $Service,
        'region' => $Region,
    ];
    // 初始化签名结构体
    $query = array_merge($query, [
        'Action' => $action,
        'Version' => $version
    ]);
    ksort($query);
    $requestParam = [
        // body是http请求需要的原生body
        'body' => $body,
        'host' => $Host,
        'path' => '/',
        'method' => $method,
        'contentType' => $ContentType,
        'date' => gmdate('Ymd\THis\Z'),
        'query' => $query
    ];
    // 第三步：接下来开始计算签名。在计算签名前，先准备好用于接收签算结果的 signResult 变量，并设置一些参数。
    // 初始化签名结果的结构体
    $xDate = $requestParam['date'];
    $shortXDate = substr($xDate, 0, 8);
    $xContentSha256 = hash('sha256', $requestParam['body']);
    $signResult = [
        'Host' => $requestParam['host'],
        'X-Content-Sha256' => $xContentSha256,
        'X-Date' => $xDate,
        'Content-Type' => $requestParam['contentType']
    ];
    // 第四步：计算 Signature 签名。
    $signedHeaderStr = join(';', ['content-type', 'host', 'x-content-sha256', 'x-date']);
    $canonicalRequestStr = join("\n", [
        $requestParam['method'],
        $requestParam['path'],
        http_build_query($requestParam['query']),
        join("\n", ['content-type:'. $requestParam['contentType'], 'host:'. $requestParam['host'], 'x-content-sha256:'. $xContentSha256, 'x-date:'. $xDate]),
        '',
        $signedHeaderStr,
        $xContentSha256
    ]);
    $hashedCanonicalRequest = hash("sha256", $canonicalRequestStr);
    $credentialScope = join('/', [$shortXDate, $credential['region'], $credential['service'], 'request']);
    $stringToSign = join("\n", ['HMAC-SHA256', $xDate, $credentialScope, $hashedCanonicalRequest]);
    $kDate = hash_hmac("sha256", $shortXDate, $credential['secretKeyId'], true);
    $kRegion = hash_hmac("sha256", $credential['region'], $kDate, true);
    $kService = hash_hmac("sha256", $credential['service'], $kRegion, true);
    $kSigning = hash_hmac("sha256", 'request', $kService, true);
    $signature = hash_hmac("sha256", $stringToSign, $kSigning);
    $signResult['Authorization'] = sprintf("HMAC-SHA256 Credential=%s, SignedHeaders=%s, Signature=%s", $credential['accessKeyId']. '/'. $credentialScope, $signedHeaderStr, $signature);
    $header = array_merge($header, $signResult);
    // 第五步：将 Signature 签名写入 HTTP Header 中，并发送 HTTP 请求。
    $client = new Client([
        'base_uri' => 'https://'. $requestParam['host'],
        'timeout' => 120.0,
    ]);
    $response = $client->request($method, 'https://'. $requestParam['host']. $requestParam['path'], [
        'headers' => $header,
        'query' => $requestParam['query'],
        'body' => $requestParam['body']
    ]);
    $responseContent = $response->getBody()->getContents();
    // 转换 \u0026 为 &
    $responseContent = str_replace('\u0026', '&', $responseContent);
    return $responseContent;
}
$now = time();
// 火山官网密钥信息, 注意sk结尾有==
$AccessKeyID = 'AK*****';
$SecretAccessKey = '*****==';

// 参考接口文档Query参数
$action = "CVProcess";
$version = "2022-08-31";

// 参考接口文档Body参数
$requestBody = [
    "req_key" => "******",
    //......
];
$body = json_encode($requestBody);

try {
    $response = request("POST", [], [], $AccessKeyID, $SecretAccessKey, $action, $version, $body);
    print_r($response);
} catch (GuzzleException $e) {
    print_r($e->getResponse()->getBody()->getContents() . "\n");
}
